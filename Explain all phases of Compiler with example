## ðŸ§   All Phases of Compiler Explained with Example

A **compiler** translates high-level source code into machine code through multiple **systematic phases**. Each phase has a specific role in ensuring correct and efficient translation.

---

## ðŸ“š **All Phases of Compiler**

Letâ€™s consider a sample statement:

```c
int x = a + b * 2;
```

Weâ€™ll walk through how this line is processed through each phase.

---

### ðŸ”¹ 1. **Lexical Analysis (Scanning)**

**Task:** Breaks source code into **tokens**
**Tool:** Lexical Analyzer (e.g., Lex)

ðŸ§ª **Output Tokens:**

* `int` â†’ Keyword
* `x` â†’ Identifier
* `=` â†’ Assignment Operator
* `a`, `b` â†’ Identifiers
* `+`, `*` â†’ Operators
* `2` â†’ Constant
* `;` â†’ Delimiter

ðŸ§  This phase also creates the **symbol table** and ignores comments/whitespace.

---

### ðŸ”¹ 2. **Syntax Analysis (Parsing)**

**Task:** Check grammatical structure using **CFG** (Context-Free Grammar)
**Tool:** Parser (e.g., YACC)

ðŸ§ª **Output:** **Parse Tree / Syntax Tree**
For `a + b * 2`, parser ensures correct operator precedence:

```
     =
   /   \
  x     +
       / \
      a   *
         / \
        b   2
```

---

### ðŸ”¹ 3. **Semantic Analysis**

**Task:** Check for **meaning**, ensure type consistency, and variable declaration.
**Error Check:** Is `a` and `b` declared? Is `int = float + string`?

ðŸ§ª **Output:** **Annotated Syntax Tree + Symbol Table**

---

### ðŸ”¹ 4. **Intermediate Code Generation (ICG)**

**Task:** Generate a language-independent code called **Intermediate Representation (IR)**

ðŸ§ª **Output (Three Address Code):**

```
T1 = b * 2
T2 = a + T1
x = T2
```

---

### ðŸ”¹ 5. **Code Optimization**

**Task:** Improve performance by removing redundancy or simplifying expressions.

ðŸ§ª **Example Optimizations:**

* If `b = 3`, replace `b * 2` with `6`
* Remove unused variables

Optimized:

```
T1 = a + (b * 2)
x = T1
```

---

### ðŸ”¹ 6. **Code Generation**

**Task:** Convert IR into **target machine code or assembly**

ðŸ§ª **Output:**

```asm
MOV R1, b
MUL R1, 2
ADD R1, a
MOV x, R1
```

---

### ðŸ”¹ 7. **Code Linking and Assembly**

**Task:** Link object files, resolve function/library references
**Output:** Final **executable (.exe)** file

---

## âœ… **Summary Table**

| Phase              | Description                            | Output                        |
| ------------------ | -------------------------------------- | ----------------------------- |
| Lexical Analysis   | Tokenizes input                        | Tokens                        |
| Syntax Analysis    | Checks structure                       | Parse Tree                    |
| Semantic Analysis  | Ensures meaning and type correctness   | Annotated Tree + Symbol Table |
| Intermediate Code  | Platform-independent code              | 3-Address Code or IR          |
| Code Optimization  | Improves code                          | Optimized IR                  |
| Code Generation    | Generates target machine/assembly code | Assembly or Machine Code      |
| Linking & Assembly | Combines code with libraries           | Executable File               |

---

### ðŸ§  In Simple Words:

> A compiler is like a **7-step translation pipeline**:
> From understanding the words (**tokens**) â†’ to grammar (**syntax**) â†’ to meaning (**semantics**) â†’ to a smart plan (**optimization**) â†’ to final instructions (**machine code**).

---

